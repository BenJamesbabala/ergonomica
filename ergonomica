#!/usr/bin/python
# -*- coding: utf-8 -*-
# pylint: disable=W0703

# pylint messes up on readline for some reason
# pylint: disable=no-member

# pylint is silly with relative imports
# pylint: disable=relative-import

# decomposing comprehensions would be bad
# pylint: disable=line-too-long

"""
[ergonomica.py]

The ergonomica runtime.
"""

import os
import itertools
import re
import difflib
import sys

# lib/lib
try:
    from lib.lib import readline
except ImportError:
    import readline

# lib/lang
from lib.lang import completer
from lib.lang.parser import tokenize
from lib.lang.operator import get_operator

# lib/verbs
from lib.verbs import verbs

# lib/load
from lib.load.config import PROMPT

# allow autocomplete (tab)
readline.set_completer(completer.completer)
readline.parse_and_bind("tab: complete")

# read config file
try:
    LINES = open(os.path.expanduser("~/.ergo/.ergo_profile"), 'r').read().split("\n")
    LINES = [x for x in LINES if (x != "") and (x[0] != "#")] # filter out comments
except IOError as error:
    print "An error occurred when accessing .ergo_profile: " + str(error)
      
# read history
try:
    HIST_FILE = open(os.path.expanduser("~/.ergo/.ergo_history"), 'a')
    HIST = open(os.path.expanduser("~/.ergo/.ergo_history"), "r").read().split("\n")
    for item in HIST[:-1]:
        readline.add_history(item)
except IOError as error:
    print "An error occured while accessing ~/.ergo_history: " + str(error)

while verbs.run:
    try:
        if len(sys.argv) == 2:
            verbs.run = False
            STDIN = sys.argv[1]
        else:
            STDIN = raw_input(PROMPT.replace("&user", verbs.user).replace("&dir", verbs.directory))
        HIST_FILE.write(STDIN + "\n")
        #evaluate variables
        try:
            MATCHES = re.search(r"\$\((.*?)\)", STDIN).groups()
            for item in MATCHES:
                STDIN = STDIN.replace("$(%s)" % (item), verbs.namespace[item])
        except AttributeError:
            pass

        STDOUT = []

        # args to pipe into next-exec function
        LAST_ARGS = []
        # (splice)
        LASTLAST_ARGS = []

        # kwargs to pipe into next-exec function
        LAST_KWARGS = {}
        # kwargs for (splice)
        LASTLAST_KWARGS = {}

        EXEC = len(STDIN.split("->"))
        BLOCKS = STDIN.split("->")
        TOKENIZED_BLOCKS = [tokenize(x) for x in STDIN.split("->")]
        for i in range(0, len(BLOCKS)):
            try:
                EXEC -= 1
                operator = get_operator(BLOCKS[i])
                if operator:
                    if operator == "map":
                        f = eval("lambda x: " + STDIN.split("->")[i].replace("(map)", ""))
                        LASTLAST_ARGS = LAST_ARGS
                        LAST_ARGS = map(f, LAST_ARGS)
                        STDOUT = LAST_ARGS
                    elif operator == "filter":
                        f = eval("lambda x: " + STDIN.split("->")[i].replace("(filter)", ""))
                        LASTLAST_ARGS = LAST_ARGS
                        LAST_ARGS = [x for x in LAST_ARGS if f(x)]
                        STDOUT = LAST_ARGS
                    elif operator == "match":
                        pattern = re.compile(STDIN.split("->")[i].replace("(match)", ""))
                        LASTLAST_ARGS = LAST_ARGS
                        LAST_ARGS = [x for x in LAST_ARGS if re.match(BLOCKS[i].replace("(match)", "").strip(), x)]
                        STDOUT = LAST_ARGS
                    elif operator == "reverse":
                        LASTLAST_ARGS = LAST_ARGS
                        LAST_ARGS = LAST_ARGS[::-1]
                        STDOUT = LAST_ARGS
                    elif operator == "splice":
                        iters = [iter(LAST_ARGS), iter(LASTLAST_ARGS)]
                        LAST_ARGS = list(filter(None, sum(itertools.izip_longest(LASTLAST_ARGS, LAST_ARGS), ())))
                        STDOUT = LAST_ARGS
                    elif operator == "kwsplice":
                        LASTLAST_KWARGS = LAST_KWARGS
                        LAST_KWARGS = {LAST_ARGS[i]:LASTLAST_ARGS[i] for i in range(len(LAST_ARGS))}
                    elif operator == "decompose":
                        LASTLAST_ARGS = LAST_ARGS
                        LAST_ARGS = [x[0] for x in LAST_ARGS].join([x[1] for x in LAST_ARGS])
                else: #elif not cmd_check(TOKENIZED_BLOCKS):
                    func = verbs.verbs[TOKENIZED_BLOCKS[i][0][0]]
                    args = LAST_ARGS + TOKENIZED_BLOCKS[i][0][1:]
                    LAST_KWARGS.update({s.split(":")[0]:s.split(":")[1] for s in TOKENIZED_BLOCKS[i][1]})
                    kwargs = LAST_KWARGS
                    STDOUT = func(args, kwargs)

                # filter out none
                try:
                    if isinstance(STDOUT, list):
                        STDOUT = [x for x in STDOUT if x != None]
                except TypeError:
                    STDOUT = []
            except Exception, error:
                # unkown command
                if (TOKENIZED_BLOCKS[i][0][0] not in verbs.verbs) and not operator:
                    bad_command = TOKENIZED_BLOCKS[i][0][0]
                    correction = difflib.get_close_matches(bad_command,verbs.verbs.keys(),1,0.75)
                    print "[ergo: CommandError]: No such command '%s'." % bad_command
                    try:

                        print " " * 22 + "Did you mean %s?" % (correction[0])
                    except IndexError:
                        pass
                else:
                    STDOUT = repr(error)
            #LASTLAST = LAST
            if not isinstance(STDOUT, list):
                LAST_ARGS = [STDOUT]
                if (not EXEC) and (STDOUT != None):
                    print(STDOUT)
            else:
                LAST_ARGS = []
                for item in STDOUT:
                    LAST_ARGS.append(item)
                    if not EXEC:
                        print(item)
    except KeyboardInterrupt:
        print("\n")
