#!/usr/bin/python
# -*- coding: utf-8 -*-
# pylint: disable=W0703

# pylint messes up on readline for some reason
# pylint: disable=no-member

# pylint is silly with relative imports
# pylint: disable=relative-import

# decomposing comprehensions would be bad
# pylint: disable=line-too-long

# all code is client-side run under the user's account
# pylint: disable=eval-used

# pylint doesn't know where files are being imported
# pylint: disable=no-name-in-module
# pylint: disable=import-error
# pylint: disable=ungrouped-imports

# pylint: disable=wrong-import-position
# pylint: disable=invalid-name

# required for py2-3 cross compat
# pylint: disable=redefined-builtin

"""
[ergonomica.py]

The ergonomica runtime.
"""

from __future__ import print_function

try:
    input = raw_input
except NameError:
   pass

import os
import re
import sys
import traceback

# lib/lib
_readline = True
try:
    from lib import readline
except ImportError:
    try:
        import readline
    except ImportError:
        _readline = False

# lib/lang
from lib.lang import completer
from lib.lang.parser import tokenize, expand_sub_expressions
from lib.lang.operator import run_operator
from lib.lang.statement import get_statement
from lib.lang.error_handler import get_error_message
from lib.lang.environment import Environment
from lib.lang.error import ErgonomicaError
from lib.lang.pipe import StaticPipeline

# lib/load
from lib.load.load_commands import verbs

# lib/misc
from lib.misc.arguments import print_arguments
from lib.misc.arguments import process_arguments


# allow autocomplete (tab)
if _readline:
    readline.set_completer(completer.completer)
    readline.parse_and_bind("tab: complete")

# initialize environment
ENV = Environment()
ENV.verbs = verbs

if ENV.editor_mode:
    if _readline:
        readline.parse_and_bind('set editing-mode %s' % (ENV.editor_mode))

# read history
try:
    HIST_FILE = open(os.path.join(os.path.expanduser("~"),".ergo",".ergo_history"), 'a')
    HIST = open(os.path.join(os.path.expanduser("~"),".ergo",".ergo_history"), "r").read().split("\n")
    if _readline:
        for hist_item in HIST[:-1]:
            readline.add_history(hist_item)
except IOError:
    _, error, _ = sys.exc_info()
    print("An error occured while accessing ~/.ergo_history: " + str(error), file=sys.stderr)

# load .ergo_profile
verbs["load_config"](ENV, [], [])
    
def ergo(stdin):
    """Main ergonomica runtime."""

    stdout = []

    pipe = StaticPipeline()

    num_blocks = len(stdin.split("->"))
    blocks = stdin.split("->")
    tokenized_blocks = [tokenize(block) for block in stdin.split("->")]

    for i in range(0, len(blocks)):
        try:
            # update loop variables
            num_blocks -= 1

            # macros
            for item in ENV.macros:
                blocks[i] = blocks[i].replace(item, ENV.macros[item])
                
            # evaluate $(exp) & replace
            blocks[i] = expand_sub_expressions(blocks[i])
            matches = re.findall(r"\$\((.*?)\)", blocks[i])

            # regenerate tokenized blocks
            tokenized_blocks[i] = tokenize(blocks[i])

            # more parse info
            statement = get_statement(blocks[i])
            evaluated_operator = run_operator(blocks[i], pipe)
            
            if blocks[i].strip() == "":
                pass
            elif evaluated_operator is not False:
                stdout = evaluated_operator
            elif statement == "run":
                lines = [open(_file, "r").read().split("\n") for _file in tokenized_blocks[i][0][1:]]
                flattened_lines = [item for sublist in lines for item in sublist]
                stdout = map(ergo, flattened_lines)
            else:
                try:
                    func = verbs[tokenized_blocks[i][0][0]]
                except KeyError:
                    if len(tokenized_blocks[i][0][0]) == 3:
                        func = verbs[[x for x in verbs if tokenized_blocks[i][0][0] == x[:3]][0]]
                args = tokenized_blocks[i][0][1:]
                try:
                    if tokenized_blocks[i][0][1:][0] == "--":
                        args = pipe.args[-1] + args[1:]
                except IndexError:
                    pass
                #pipe.kwargs[-1].update({s.split(":")[0]:s.split(":")[1] for s in tokenized_blocks[i][1]})
                kwargs = pipe.kwargs
                stdout = func(ENV, args, kwargs)

            # filter out none values
            try:
                if isinstance(stdout, list):
                    stdout = [x for x in stdout if x != None]
            except TypeError:
                stdout = []

        except ZeroDivisionError:
            _, error, _ = sys.exc_info()
            # if no ergonomica error message can be generated
            if isinstance(error, ErgonomicaError):
                raise ErgonomicaError
            if not get_error_message(blocks[i]):
                # fallback to python
                stdout = [traceback.format_exc()]
            else:
                stdout = get_error_message(blocks[i])
        if not isinstance(stdout, list):
            #pipe.args.update([stdout])
            if (not num_blocks) and (stdout != None):
                print(stdout, file=sys.stderr)
        else:
            pipe.args.append(stdout)
            if not num_blocks:
                return stdout

def print_ergo(stdin):
    """Print the result of ergo(stdin) properly."""
    try:
        stdout = ergo(stdin)
        if stdout is None:
            return
        for item in stdout:
            print(item)
    except NameError:
        return
    except IndexError:
        return
    #except Exception:
    #    _, error, _ = sys.exc_info()
    #    print(error, file=sys.stderr)

GOAL = process_arguments(sys.argv[1:])

if GOAL == "help":
    print_arguments()
    ENV.run = False

if GOAL == "run a file":
    LINES = open(sys.argv[2], "r").read().split("\n")
    map(print_ergo, LINES)

if GOAL == "run strings":
    map(print_ergo, sys.argv[2:])

if GOAL == "shell":
    while ENV.run:
        try:
            PROMPT = ENV.prompt
            PROMPT = PROMPT.replace(r"\u", ENV.user).replace(r"\w", ENV.directory)
            STDIN = input(PROMPT)
            print_ergo(STDIN)
        except KeyboardInterrupt:
            print("\n^C")
